import prelude;
import util;

-- Reorder sdiffs
reorder {dim}
  (ordering :: gnss_signal_t[dim])
  (inout measurements :: measurement[dim])
  :: () := (
  -- sort the measurements according to ordering
  for i in dim -> (
    for j in i:dim -> (
      if sid_is_equal measurements[j].sat_id ordering[i] then (
        temp := measurements[i];
        measurements[i] <- measurements[j];
        measurements[j] <- temp;
      );
    );
  );
  for i in dim -> assert sid_is_equal measurements[i].sat_id ordering[i];
);

-- ADD SAT --

add_sat
  (inout state :: filter_state)
  (new_sat :: gnss_signal_t)
  (sig_new_amb :: double)
  :: () := (
  printf "ADD: "; print_sat new_sat; print_sat_state state;
  new_num_sats := state.num_sats + 1;
  new_num_x_states := num_sats_to_num_states new_num_sats;
  p_new :: double[new_num_x_states, new_num_x_states];
  -- initial off-diagonal covariance = 0
  p_new <- (add_dimension state.P)[:new_num_x_states, :new_num_x_states];
  state.sats[new_num_sats-2] <- new_sat;
  pdim := 3 + new_num_sats - 1;
  state.x[pdim-1] <- 0.0;
  p_new[pdim-1, pdim-1] <- (sig_new_amb^2);
  state.num_sats <- new_num_sats; -- this line must happen before the next!
  state.P[:pdim, :pdim] <- p_new[:pdim, :pdim];
  --nl (); printf "\nP:\n"; print_mat_upsidedown state.P; nl ();
);

-- DROP SAT --

-- returns index of dropped sat
drop_sat_state
  (target :: gnss_signal_t)
  (inout sat_state :: filter_state)
  :: s32 := (

  index := find_sat target sat_state.sats;

  if index >= 0 then (
    dim := sat_state.num_sats; -- slight hack
    sat_state.sats[index:dim-1] <- sat_state.sats[index+1:dim];
  ) else (
    printf "ERROR; cannot drop. sat not found: "; print_sat target;
    printf "\n"; print_sat_state sat_state;
    assert False;
  );

  return index;
);

drop_sat
  (inout state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (
  printf "DROP: "; print_sat sat; print_sat_state state;
  index := drop_sat_state sat (inout state);
  x_index := sats_index_to_x_index index;
  num_states := num_sats_to_num_states state.num_sats;
  state.x[:num_states-1] <- drop_i_1_double x_index state.x[:num_states];
  P_temp := drop_i_2 x_index (drop_i_2 x_index state.P[:num_states,:num_states]^T)^T;
  state.num_sats <- state.num_sats - 1;
  state.P[:num_states-1,:num_states-1] <- P_temp;
);

drop_a_sat {n}
  (inout state :: filter_state)
  (sats :: gnss_signal_t[n])
  :: bool := (
  for i in state.num_sats - 1 -> (
    if not (contains_sat state.sats[i] sats) then (
      drop_sat (inout state) state.sats[i];
      return True;
    );
  );
  return False;
);



-- CHOOSE REF --

choose_ref {dim}
  (state :: filter_state)
  (measurements :: measurement[dim])
  :: s32 := (

  index := -1;
  max_snr := -1000.0; -- TODO check units
  for i in dim -> (
    m := measurements[i];
    if m.snr >= max_snr and contains_sat m.sat_id state.sats then (
        max_snr <- measurements[i].snr;
        index   <- i;
    ) else ();
  );

  return index;
);

-- CHANGE REF --

-- assumes sat is already part of the state
change_ref
  (inout sat_state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (

  -- have:
  -- xi = z_i - z_0
  -- xj = z_j - z_0
  -- want:
  -- xi = z_i - z_j
  -- xj = z_0 - z_j

  -- so xi <- xi - xj
  --    xj <- -xj
  --    satj <- sat0
  num_states := num_sats_to_num_states sat_state.num_sats;

  -- Construct change of basis matrix
  change :: double[num_states, num_states];
  -- sat == sat_state.sats[j]
  sats_index := find_sat sat sat_state.sats;
  x_index := sats_index_to_x_index sats_index;
  change <- scalar 1.0;
  change[:,x_index] <- -1.0;
  -- Apply update
  new_x := change * sat_state.x[:num_states];
  new_p := change * sat_state.P[:num_states,:num_states] * change^T;

  -- Update state struct
  sat_state.sats[sats_index] <- sat_state.ref;
  sat_state.ref <- sat;
  -- TODO fix struct sizing issue
  sat_state.x[:num_states] <- new_x;
  sat_state.P[:num_states,:num_states] <- new_p;
);
