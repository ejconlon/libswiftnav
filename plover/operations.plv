import prelude;
import util;

-- Reorder sdiffs
reorder {dim}
  (ordering :: gnss_signal_t[dim])
  (inout measurements :: measurement[dim])
  :: () := (
  -- sort the measurements according to ordering
  for i in dim -> (
    for j in i:dim -> (
      if sid_is_equal measurements[j].sat_id ordering[i] then (
        temp := measurements[i];
        measurements[i] <- measurements[j];
        measurements[j] <- temp;
      );
    );
  );
  for i in dim -> assert sid_is_equal measurements[i].sat_id ordering[i];
);

-- ADD SAT --

add_sat
  (inout state :: filter_state)
  (sat :: gnss_signal_t)
  (sig_new_amb :: double)
  :: () := (
  printf "ADD: "; print_sat sat; print_sat_state state;
  num := state.num_sats + 1;
  p_new :: double[num+2, num+2];
  -- initial off-diagonal covariance = 0
  p_new <- (add_dimension state.P)[:num+2, :num+2];
  state.sats[num-2] <- sat;
  pdim := 3+num-1;
  state.x[pdim-1] <- 0.0;
  p_new[pdim-1, pdim-1] <- (sig_new_amb^2);
  state.num_sats <- num; -- this line must happen before the next!
  state.P[:pdim, :pdim] <- p_new[:pdim, :pdim];
  nl (); printf "\nP:\n"; print_mat_upsidedown state.P; nl ();
);

-- DROP SAT --

-- returns index of dropped sat
drop_sat_state
  (target :: gnss_signal_t)
  (inout sat_state :: filter_state)
  :: s32 := (

  index := find_sat target sat_state.sats;

  if index >= 0 then (
    dim := sat_state.num_sats; -- slight hack
    sat_state.num_sats <- dim - 1;
    sat_state.sats[index:dim-1] <- sat_state.sats[index+1:dim];
  ) else (
    printf "ERROR; cannot drop. sat not found: "; print_sat target;
    printf "\n"; print_sat_state sat_state;
    assert False;
  );

  return index;
);

drop_sat
  (inout state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (
  printf "DROP: "; print_sat sat; print_sat_state state;
  index := drop_sat_state sat (inout state);
  x_index := sats_index_to_x_index index;
  -- TODO check
  dim := state.num_sats+2;
  state.x[0..dim-1] <- drop_i_1_double x_index state.x[0..dim];
  state.P[0..dim-1,0..dim-1] <- drop_i_2 x_index (drop_i_2 x_index state.P[0..dim,0..dim]^T)^T;
);

drop_a_sat {n}
  (inout state :: filter_state)
  (sats :: gnss_signal_t[n])
  :: bool := (
  for i in state.num_sats - 1 -> (
    if not (contains_sat state.sats[i] sats) then (
      drop_sat (inout state) state.sats[i];
      return True;
    );
  );
  return False;
);



-- CHOOSE REF --

choose_ref {dim}
  (state :: filter_state)
  (measurements :: measurement[dim])
  :: s32 := (

  index := -1;
  max_snr := -1000.0; -- TODO check units
  for i in dim -> (
    m := measurements[i];
    if m.snr >= max_snr and contains_sat m.sat_id state.sats then (
        max_snr <- measurements[i].snr;
        index   <- i;
    ) else ();
  );

  return index;
);

-- CHANGE REF --

-- assumes sat is already part of the state
change_ref
  (inout sat_state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (

  -- have:
  -- xi = z_i - z_0
  -- xj = z_j - z_0
  -- want:
  -- xi = z_i - z_j
  -- xj = z_0 - z_j

  -- so xi <- xi - xj
  --    xj <- -xj
  --    satj <- sat0
  sats := sat_state.num_sats;
  dim := sats+2;

  -- Construct change of basis matrix
  change :: double[dim, dim];
  -- sat == sat_state.sats[j]
  j := sats_index_to_x_index $ find_sat sat sat_state.sats;
  change <- scalar 1.0;
  change[j,j] <- -1;
  for i in dim -> if i != j then change[i,j] <- -1;
  -- Apply update
  new_x := change * sat_state.x[:dim];
  new_p := change * sat_state.P[:dim,:dim] * change^T;

  -- Update state struct
  sat_state.sats[j] <- sat_state.ref;
  sat_state.ref <- sat;
  -- TODO fix struct sizing issue
  sat_state.x[:dim] <- new_x;
  sat_state.P[:dim,:dim] <- new_p;
);
