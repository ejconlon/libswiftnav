import prelude;

__C__ "#include <libswiftnav/linear_algebra.h>";
__C__ "#include <libswiftnav/constants.h>";
__C__ "#include <libswiftnav/signal.h>";
__C__ "#include <libswiftnav/observation.h>";

extern MAX_FILTER_STATE_DIM :: int;
__C__ "#define MAX_FILTER_STATE_DIM 15";

extern (
  GPS_L1_LAMBDA :: double;
  GPS_C :: double;

  -- we don't use the fields; only call functions with gnss_signal_t parameters
  -- TODO make parser accept empty struct definition
  struct gnss_signal_t (
    sat :: u16;
    code :: u16; -- taken from enum values below
  );

  struct sdiff_t (
    pseudorange :: double;
    carrier_phase :: double;
    snr :: double;
    sid :: gnss_signal_t;
    sat_pos :: double[3];
  );

  CODE_INVALID :: s32;
  CODE_GPS_L1CA :: s32;
  CODE_GPS_L2CM :: s32;
  CODE_SBAS_L1CA :: s32;
  CODE_COUNT :: s32;

  sid_to_code_index (x :: gnss_signal_t) :: u16;
  sid_is_equal(a :: gnss_signal_t) (b :: gnss_signal_t) :: bool;
);

struct sat_state (
  ambs :: s32;
  sats :: gnss_signal_t[MAX_FILTER_STATE_DIM] storing gnss_signal_t[ambs];
  x :: double[MAX_FILTER_STATE_DIM] storing double[ambs];
);

struct amb_state (
  valid :: bool;
  ambs :: s32;
  ref :: gnss_signal_t;
  sats :: gnss_signal_t[MAX_FILTER_STATE_DIM] storing gnss_signal_t[ambs];
  x :: double[MAX_FILTER_STATE_DIM] storing double[ambs];
);

struct baseline_state (
  -- TODO add constant (3) dim member?
  double :: double[3];
);

-- MAX_FILTER_STATE_DIM = max(num_sats) + 2
struct filter_state (
  first_amb_idx :: s32;
  l1_state :: amb_state;
  l2_state :: amb_state;
  baseline :: baseline_state;
  P :: double[MAX_FILTER_STATE_DIM, MAX_FILTER_STATE_DIM] storing
       double[3 + l1_state.ambs + l2_state.ambs,
              3 + l1_state.ambs + l2_state.ambs];
);

num_sats
  (s :: amb_state)
  :: s32 := (
  n := s.ambs;
  if s.valid then n <- n + 1;
  n
);

get_num_sats
  (s :: filter_state)
  :: s32 := num_sats s.l1_state + num_sats s.l2_state;

get_state_dimension
  (s :: filter_state)
  :: s32 := 3 ;

struct sat_array (
  dim :: s32;
  array :: gnss_signal_t[MAX_FILTER_STATE_DIM] storing gnss_signal_t[dim];
);

-- Reorder sdiffs
reorder {dim}
  (ordering :: gnss_signal_t[dim])
  (inout sdiffs :: sdiff_t[dim])
  :: () := (
  -- sort the sdiffs according to ordering
  for i in dim -> (
    for j in i:dim -> (
      if sid_is_equal sdiffs[j].sid ordering[i] then (
        temp := sdiffs[i];
        sdiffs[i] <- sdiffs[j];
        sdiffs[j] <- temp;
      );
    );
  );
  for i in dim -> assert sid_is_equal sdiffs[i].sid ordering[i];
);

-- TODO base type polymorphism
drop_i_1_double {d}
  (i :: u32)
  (v :: double[d])
  :: double[d-1] := (
  u :: double[d-1];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

drop_i_1_s32 {d}
  (i :: u32)
  (v :: s32[d])
  :: s32[d-1] := (
  u :: s32[d-1];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

drop_i_2 {d, n}
  (i :: u32)
  (v :: double[d,n])
  :: double[d-1,n] := (
  u :: double[d-1,n];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

find_sat {dim}
  (target :: gnss_signal_t)
  (sats :: gnss_signal_t[dim])
  :: s32 := (
  for i in dim -> (
    if sid_is_equal target sats[i] then
      return i
  );
  return -1;
);

get_index_bounds
  (state :: filter_state)
  (sat :: gnss_signal_t)
  (out lower :: s32)
  (out upper :: s32)
  :: () := (
    if sat.code == CODE_GPS_L1CA then (
      lower <- state.first_amb_idx;
      upper <- lower + state.l1_state.ambs;
    ) else if sat.code == CODE_GPS_L2CM then (
      lower <- state.first_amb_idx + state.l1_state.ambs;
      upper <- lower + state.l2_state.ambs;
    ) else (
      print_sat sat;
      printf "Invalid code.\n";
      assert False;
    );
);

sats_index_to_x_index
  (s :: filter_state)
  (sats_index :: s32)
  :: s32 := return sats_index + s.first_amb_idx;

contains_sat {dim}
  (target :: gnss_signal_t)
  (sats :: gnss_signal_t[dim])
  :: bool := find_sat target sats >= 0;

-- Adding a new row/col of zeroes to a matrix
add_dimension {dim}
  (m :: double[dim, dim])
  :: double[dim+1, dim+1] := (
  result :: double[dim+1, dim+1];
  end := dim;
  result[:end, :end] <- m[:end, :end];
  result[end, 0..end] <- 0;
  result[0..end, end] <- 0;
  result;
);

-- TODO unneeded?
insert_sat {dim}
  (array :: gnss_signal_t[dim])
  (index :: s32)
  (value :: gnss_signal_t)
  :: (gnss_signal_t[dim+1]) := (
  new_array :: gnss_signal_t[dim+1];
  new_array[0:index] <- array[0:index];
  new_array[index] <- value;
  new_array[index+1:]  <- array[index:];
  return new_array;
);

insert_double {dim}
  (array :: double[dim])
  (index :: s32)
  (value :: double)
  :: (double[dim+1]) := (
  new_array :: double[dim+1];
  new_array[0:index] <- array[0:index];
  new_array[index] <- value;
  new_array[index+1:]  <- array[index:];
  return new_array;
);

insert_dimension {dim}
  (m :: double[dim, dim])
  (index :: s32)
  (out result :: double[dim+1, dim+1])
  :: () := (

  result[index, :] <- 0;
  result[:, index] <- 0;

  result[:index, :index] <- m[:index, :index];
  result[index+1:, :index] <- m[index:, :index];
  result[:index, index+1:] <- m[:index, index:];
  result[index+1:, index+1:] <- m[index:, index:];
);

double_matrix_equal {m, n}
  (x :: double[m, n])
  (y :: double[m, n])
  :: bool := (
    for i in m ->
      for j in n ->
        if not (x[i, j] == y[i, j]) then return False;
    return True;
);

zeros {m,n}
  :: double[m,n] := (
  r :: double[m,n];
  r <- 0.0;
  r;
);

block_diagonal {r1, c1, r2, c2}
  (mat1 :: double[r1, c1])
  (mat2 :: double[r2, c2])
  :: double[r1 + r2, c1 + c2] := (
  result :: double[r1 + r2, c1 + c2];
  result <- 0;
  result[:r1, :c1] <- mat1;
  result[r1:, c1:] <- mat2;
  return result;
);
-- Print utils
nl () :: () := (printf "\n"; ());

print_sat (s :: gnss_signal_t) :: s32 := printf "%d" s.sat;

print_sats {n} (s :: gnss_signal_t[n]) :: () := (
  printf "[";
  for i in n -> (
    if i > 0 then printf ", " else 0;
    print_sat s[i];
  ); printf "]\n"; ();
);

print_filter_sat_state (s :: filter_state) :: () := (
  print_sat_state s.l1_state; print_sat_state s.l2_state;
);

print_sat_state (s :: amb_state) :: () := (
  printf "(";
  if s.valid then (printf "ref: "; print_sat s.ref; ());
  printf ")";
  print_sats s.sats; ()
);

print_mat_upsidedown {n,m} (A :: double[n,m]) :: () := (
  printf "mat(";
   for i in (n-1)..0:-1 -> (
     if i < n then printf ";\n    " else 0;
     for j in m -> (
       if j > 0 then printf "," else 0;
       printf "% 12lf" A[i,j];
     );
   );
   printf ")\n";
   ();
);
