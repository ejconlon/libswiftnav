import prelude;

__C__ "#include <libswiftnav/linear_algebra.h>";
__C__ "#include <libswiftnav/constants.h>";
__C__ "#include <libswiftnav/signal.h>";
__C__ "#include <libswiftnav/observation.h>";

extern MAX_FILTER_STATE_DIM :: int;
__C__ "#define MAX_FILTER_STATE_DIM 15";

extern (
  GPS_L1_LAMBDA :: double;
  GPS_C :: double;

  -- we don't use the fields; only call functions with gnss_signal_t parameters
  -- TODO make parser accept empty struct definition
  struct gnss_signal_t (
    sat :: u16;
    code :: u16; -- taken from enum values below
  );

  struct sdiff_t (
    pseudorange :: double;
    carrier_phase :: double;
    snr :: double;
    sid :: gnss_signal_t;
    sat_pos :: double[3];
  );

  CODE_INVALID :: s32;
  CODE_GPS_L1CA :: s32;
  CODE_GPS_L2CM :: s32;
  CODE_SBAS_L1CA :: s32;
  CODE_COUNT :: s32;

  sid_to_code_index (x :: gnss_signal_t) :: u16;
  sid_is_equal(a :: gnss_signal_t) (b :: gnss_signal_t) :: bool;
);

-- MAX_FILTER_STATE_DIM = max(num_sats) + 2
struct filter_state (
  first_amb_idx :: s32;
  l1_valid :: bool;
  l2_valid :: bool;
  l1_ambs :: s32;
  l2_ambs :: s32;
  l1_ref :: gnss_signal_t;
  l2_ref :: gnss_signal_t;
  sats :: gnss_signal_t[MAX_FILTER_STATE_DIM] storing gnss_signal_t[l1_ambs + l2_ambs];
  x :: double[MAX_FILTER_STATE_DIM] storing double[first_amb_idx + l1_ambs + l2_ambs];
  P :: double[MAX_FILTER_STATE_DIM, MAX_FILTER_STATE_DIM] storing double[first_amb_idx + l1_ambs + l2_ambs, first_amb_idx + l1_ambs + l2_ambs];
);

num_l1_sats
  (s :: filter_state)
  :: s32 := (
  n := s.l1_ambs;
  if s.l1_valid then n <- n + 1;
  n
);

num_l2_sats
  (s :: filter_state)
  :: s32 := (
  n := s.l2_ambs;
  if s.l2_valid then n <- n + 1;
  n
);

get_num_sats
  (s :: filter_state)
  :: s32 := num_l1_sats s + num_l2_sats s;

get_state_dimension
  (s :: filter_state)
  :: s32 := s.first_amb_idx + s.l1_ambs + s.l2_ambs;


struct sat_array (
  dim :: s32;
  array :: gnss_signal_t[MAX_FILTER_STATE_DIM] storing gnss_signal_t[dim];
);

all_sats
  (s :: filter_state)
  (out result :: sat_array)
  :: () := (
  len := 0;
  if s.l1_valid then (
    result.array[len] <- s.l1_ref;
    len <- len + 1;
  );
  if s.l2_valid then (
    result.array[len] <- s.l2_ref;
    len <- len + 1;
  );

  result.array[len : len + s.l1_ambs + s.l2_ambs] <- s.sats;
  result.dim <- len + s.l1_ambs + s.l2_ambs;
);

-- Reorder sdiffs
reorder {dim}
  (ordering :: gnss_signal_t[dim])
  (inout sdiffs :: sdiff_t[dim])
  :: () := (
  -- sort the sdiffs according to ordering
  for i in dim -> (
    for j in i:dim -> (
      if sid_is_equal sdiffs[j].sid ordering[i] then (
        temp := sdiffs[i];
        sdiffs[i] <- sdiffs[j];
        sdiffs[j] <- temp;
      );
    );
  );
  for i in dim -> assert sid_is_equal sdiffs[i].sid ordering[i];
);

-- TODO base type polymorphism
drop_i_1_double {d}
  (i :: u32)
  (v :: double[d])
  :: double[d-1] := (
  u :: double[d-1];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

drop_i_1_s32 {d}
  (i :: u32)
  (v :: s32[d])
  :: s32[d-1] := (
  u :: s32[d-1];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

drop_i_2 {d, n}
  (i :: u32)
  (v :: double[d,n])
  :: double[d-1,n] := (
  u :: double[d-1,n];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

find_sat {dim}
  (target :: gnss_signal_t)
  (sats :: gnss_signal_t[dim])
  :: s32 := (
  for i in dim -> (
    if sid_is_equal target sats[i] then
      return i
  );
  return -1;
);

increment_amb_count
  (inout state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (
    if sat.code == CODE_GPS_L1CA then (
      state.l1_ambs <- state.l1_ambs + 1;
    ) else if sat.code == CODE_GPS_L2CM then (
      state.l2_ambs <- state.l2_ambs + 1;
    ) else (
      print_sat sat;
      printf "Invalid code.\n";
      assert False;
    );
);

decrement_amb_count
  (inout state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (
    if sat.code == CODE_GPS_L1CA then (
      state.l1_ambs <- state.l1_ambs - 1;
    ) else if sat.code == CODE_GPS_L2CM then (
      state.l2_ambs <- state.l2_ambs - 1;
    ) else (
      print_sat sat;
      printf "Invalid code.\n";
      assert False;
    );
);

get_index_bounds
  (state :: filter_state)
  (sat :: gnss_signal_t)
  (out lower :: s32)
  (out upper :: s32)
  :: () := (
    if sat.code == CODE_GPS_L1CA then (
      lower <- state.first_amb_idx;
      upper <- lower + state.l1_ambs;
    ) else if sat.code == CODE_GPS_L2CM then (
      lower <- state.first_amb_idx + state.l1_ambs;
      upper <- lower + state.l2_ambs;
    ) else (
      print_sat sat;
      printf "Invalid code.\n";
      assert False;
    );
);

sats_index_to_x_index
  (s :: filter_state)
  (sats_index :: s32)
  :: s32 := return sats_index + s.first_amb_idx;

num_sats_to_num_states
  (s :: filter_state)
  (num_sats :: s32)
  :: s32 := return num_sats + s.first_amb_idx - 2;

contains_sat {dim}
  (target :: gnss_signal_t)
  (sats :: gnss_signal_t[dim])
  :: bool := find_sat target sats >= 0;

-- Adding a new row/col of zeroes to a matrix
add_dimension {dim}
  (m :: double[dim, dim])
  :: double[dim+1, dim+1] := (
  result :: double[dim+1, dim+1];
  end := dim;
  result[:end, :end] <- m[:end, :end];
  result[end, 0..end] <- 0;
  result[0..end, end] <- 0;
  result;
);

insert_sat {dim}
  (array :: gnss_signal_t[dim])
  (index :: s32)
  (value :: gnss_signal_t)
  :: (gnss_signal_t[dim+1]) := (
  new_array :: gnss_signal_t[dim+1];
  new_array[0:index] <- array[0:index];
  new_array[index] <- value;
  new_array[index+1:]  <- array[index:];
  return new_array;
);

insert_double {dim}
  (array :: double[dim])
  (index :: s32)
  (value :: double)
  :: (double[dim+1]) := (
  new_array :: double[dim+1];
  new_array[0:index] <- array[0:index];
  new_array[index] <- value;
  new_array[index+1:]  <- array[index:];
  return new_array;
);

insert_dimension {dim}
  (m :: double[dim, dim])
  (index :: s32)
  (out result :: double[dim+1, dim+1])
  :: () := (

  result[index, :] <- 0;
  result[:, index] <- 0;

  result[:index, :index] <- m[:index, :index];
  result[index+1:, :index] <- m[index:, :index];
  result[:index, index+1:] <- m[:index, index:];
  result[index+1:, index+1:] <- m[index:, index:];
);

double_matrix_equal {m, n}
  (x :: double[m, n])
  (y :: double[m, n])
  :: bool := (
    for i in m ->
      for j in n ->
        if not (x[i, j] == y[i, j]) then return False;
    return True;
);

-- Print utils
nl () :: () := (printf "\n"; ());

print_sat (s :: gnss_signal_t) :: s32 := printf "%d" s.sat;

print_sats {n} (s :: gnss_signal_t[n]) :: () := (
  printf "[";
  for i in n -> (
    if i > 0 then printf ", " else 0;
    print_sat s[i];
  ); printf "]\n"; ();
);

print_sat_state (s :: filter_state) :: () := (
  printf "(";
  if s.l1_valid then (printf "l1: "; print_sat s.l1_ref; printf ", "; ());
  if s.l2_valid then (printf "l2: "; print_sat s.l2_ref; ());
  printf ")";
  print_sats s.sats; ()
);

print_mat_upsidedown {n,m} (A :: double[n,m]) :: () := (
  printf "mat(";
   for i in (n-1)..0:-1 -> (
     if i < n then printf ";\n    " else 0;
     for j in m -> (
       if j > 0 then printf "," else 0;
       printf "% 12lf" A[i,j];
     );
   );
   printf ")\n";
   ();
);
