import prelude;

__C__ "#include <libswiftnav/linear_algebra.h>";
__C__ "#include <libswiftnav/constants.h>";
__C__ "#include <libswiftnav/signal.h>";
__C__ "#include <libswiftnav/observation.h>";

extern MAX_FILTER_STATE_DIM :: int;
__C__ "#define MAX_FILTER_STATE_DIM 15";

extern (
  GPS_L1_LAMBDA :: double;

  -- we don't use the fields; only call functions with gnss_signal_t parameters
  -- TODO make parser accept empty struct definition
  struct gnss_signal_t (
    sat :: u16;
    code :: u16; -- taken from enum values below
  );

  struct sdiff_t (
    pseudorange :: double;
    carrier_phase :: double;
    snr :: double;
    sid :: gnss_signal_t;
    sat_pos :: double[3];
  );

  CODE_INVALID :: s32;
  CODE_GPS_L1CA :: s32;
  CODE_GPS_L2CM :: s32;
  CODE_SBAS_L1CA :: s32;
  CODE_COUNT :: s32;

  sid_to_code_index (x :: gnss_signal_t) :: u16;
  sid_is_equal(a :: gnss_signal_t) (b :: gnss_signal_t) :: bool;
);

struct measurement (
  pseudorange :: double;
  carrier_phase :: double;
  snr :: double;
  sat_id :: gnss_signal_t;
  sat_pos :: double[3];
);


sdiffs_convert {dim}
  (sdiffs :: sdiff_t[dim])
  (out ms :: measurement[dim])
  :: () := (
  for i in dim -> (
    ms[i].pseudorange <- sdiffs[i].pseudorange;
    ms[i].carrier_phase <- sdiffs[i].carrier_phase;
    ms[i].snr <- sdiffs[i].snr;
    ms[i].sat_id <- sdiffs[i].sid;
    ms[i].sat_pos <- sdiffs[i].sat_pos;
  );
);

-- MAX_FILTER_STATE_DIM = max(num_sats) + 2
struct filter_state (
  num_sats :: int; -- must be at least 1!
  ref :: gnss_signal_t;
  sats :: gnss_signal_t[MAX_FILTER_STATE_DIM] storing gnss_signal_t[num_sats-1];
  invalid :: bool;
  initialized :: bool;
  x :: double[MAX_FILTER_STATE_DIM] storing double[num_sats+2];
  P :: double[MAX_FILTER_STATE_DIM, MAX_FILTER_STATE_DIM] storing double[num_sats+2, num_sats+2];
);

-- Reorder sdiffs
reorder {dim}
  (ordering :: gnss_signal_t[dim])
  (inout measurements :: measurement[dim])
  :: () := (
  -- sort the measurements according to ordering
  for i in dim -> (
    for j in i:dim -> (
      if sid_is_equal measurements[j].sat_id ordering[i] then (
        temp := measurements[i];
        measurements[i] <- measurements[j];
        measurements[j] <- temp;
      );
    );
  );
  for i in dim -> assert sid_is_equal measurements[i].sat_id ordering[i];
);

-- TODO base type polymorphism
drop_i_1_double {d}
  (i :: u32)
  (v :: double[d])
  :: double[d-1] := (
  u :: double[d-1];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

drop_i_1_s32 {d}
  (i :: u32)
  (v :: s32[d])
  :: s32[d-1] := (
  u :: s32[d-1];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

drop_i_2 {d, n}
  (i :: u32)
  (v :: double[d,n])
  :: double[d-1,n] := (
  u :: double[d-1,n];
  u[0:i] <- v[0:i];
  u[i:]  <- v[i+1:];
  u;
);

find_sat {dim}
  (target :: gnss_signal_t)
  (sats :: gnss_signal_t[dim])
  :: s32 := (
  for i in dim -> (
    if sid_is_equal target sats[i] then
      return i
  );
  return -1;
);

sats_index_to_x_index
  (sats_index :: s32)
  :: s32 := return sats_index + 3;

num_sats_to_num_states
  (num_sats :: s32)
  :: s32 := return num_sats + 3 - 1;

contains_sat {dim}
  (target :: gnss_signal_t)
  (sats :: gnss_signal_t[dim])
  :: bool := find_sat target sats >= 0;

-- Adding a new row/col of zeroes to a matrix
add_dimension {dim}
  (m :: double[dim, dim])
  :: double[dim+1, dim+1] := (
  result :: double[dim+1, dim+1];
  end := dim;
  result[:end, :end] <- m[:end, :end];
  result[end, 0..end] <- 0;
  result[0..end, end] <- 0;
  result;
);

-- Print utils
nl () :: () := (printf "\n"; ());

print_sat (s :: gnss_signal_t) :: s32 := printf "%d" s.sat;

print_sats {n} (s :: gnss_signal_t[n]) :: () := (
  printf "[";
  for i in n -> (
    if i > 0 then printf ", " else 0;
    print_sat s[i];
  ); printf "]\n"; ();
);

print_sat_state (s :: filter_state) :: () := (
  if s.invalid then (printf "state empty\n"; ())
  else (printf "("; print_sat s.ref; printf ")"; print_sats s.sats;);
);

print_mat_upsidedown {n,m} (A :: double[n,m]) :: () := (
  printf "mat(";
   for i in (n-1)..0:-1 -> (
     if i < n then printf ";\n    " else 0;
     for j in m -> (
       if j > 0 then printf "," else 0;
       printf "% 12lf" A[i,j];
     );
   );
   printf ")\n";
   ();
);
