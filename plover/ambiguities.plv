import prelude;
import qr;
import util;
import constants;

-- ADD SAT --

add_sats {n_sdiffs}
  (inout state :: filter_state)
  (sdiff_sats :: gnss_signal_t[n_sdiffs])
  :: () := (
  for i in n_sdiffs -> (
    array :: sat_array;
    all_sats state (out array);

    if not (contains_sat sdiff_sats[i] array.array) then
      add_sat (inout state) sdiff_sats[i]

    --if not (contains_sat sdiff_sats[i] state.sats or
    --        (state.l1_valid and sid_is_equal sdiff_sats[i] state.l1_ref) or
    --        (state.l2_valid and sid_is_equal sdiff_sats[i] state.l2_ref)) then
    --  add_sat (inout state) sdiff_sats[i]
  );
);

add_sat
  (inout state :: filter_state)
  (new_sat :: gnss_signal_t)
  :: () := (
  sig_new_amb :: double;
  new_sat_idx :: s32;

  if new_sat.code == CODE_GPS_L1CA then (
    sig_new_amb <- sig_init_p / GPS_L1_LAMBDA;
    new_sat_idx <- s.l1_ambs;
  ) else if new_sat.code == CODE_GPS_L2CA then
    sig_new_amb <- sig_init_p / GPS_L2_LAMBDA;
    new_sat_idx <- s.l1_ambs + s.l2_ambs;
  ) else (
      printf "Invalid sat code found: %d\n" new_sat.code;
      assert False;
  );
  printf "ADD: "; print_sat new_sat; print_sat_state state;

  -- x index
  new_x_index = sats_index_to_x_index new_sat_idx;
  p_new :: double[s.first_amb_idx + s.l1_ambs + s.l2_ambs, s.first_amb_idx + s.l1_ambs + s.l2_ambs];

  -- TODO here we are:

  -- add to sats
  insert_array state.sats new_sat_idx new_sat;
  -- add to x
  insert_array state.x new_x_index 0.0;
  -- add to P
  insert_dimension state.P new_x_index p_new;

  -- increment l1_ambs or l2_ambs
  -- copy values






  new_num_sats := state.num_sats + 1;
  new_num_x_states := num_sats_to_num_states new_num_sats;
  p_new :: double[new_num_x_states, new_num_x_states];
  -- initial off-diagonal covariance = 0

  --p_new <- (add_dimension state.P)[:new_num_x_states, :new_num_x_states];
  insert_dimension P ?? p_new;

  state.sats[new_num_sats-2] <- new_sat;
  pdim := 3 + new_num_sats - 1;
  state.x[pdim-1] <- 0.0;
  p_new[pdim-1, pdim-1] <- (sig_new_amb^2);
  state.num_sats <- new_num_sats; -- this line must happen before the next!
  state.P[:pdim, :pdim] <- p_new[:pdim, :pdim];
  --nl (); printf "\nP:\n"; print_mat state.P; nl ();
);

{-

-- DROP SAT --

-- returns index of dropped sat
drop_sat_state
  (target :: gnss_signal_t)
  (inout sat_state :: filter_state)
  :: s32 := (

  index := find_sat target sat_state.sats;

  if index >= 0 then (
    dim := sat_state.num_sats; -- slight hack
    sat_state.sats[index:dim-1] <- sat_state.sats[index+1:dim];
  ) else (
    printf "ERROR; cannot drop. sat not found: "; print_sat target;
    printf "\n"; print_sat_state sat_state;
    assert False;
  );

  return index;
);

drop_sat
  (inout state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (
  printf "DROP: "; print_sat sat; printf " from "; print_sat_state state;
  printf "before drop:\n"; print_vec state.x; print_sats state.sats;
  index := drop_sat_state sat (inout state);
  x_index := sats_index_to_x_index index;
  num_states := num_sats_to_num_states state.num_sats;
  x_temp := drop_i_1_double x_index state.x[:num_states];
  P_temp := drop_i_2 x_index (drop_i_2 x_index state.P[:num_states,:num_states]^T)^T;
  state.num_sats <- state.num_sats - 1;
  state.x[:num_states-1] <- x_temp;
  state.P[:num_states-1,:num_states-1] <- P_temp;

  printf "after drop:\n"; print_vec state.x; print_sats state.sats;
);

drop_a_sat {n}
  (inout state :: filter_state)
  (sdiff_sats :: gnss_signal_t[n])
  :: bool := (
  for i in state.num_sats - 1 -> (
    if not (contains_sat state.sats[i] sdiff_sats) then (
      drop_sat (inout state) state.sats[i];
      return True;
    );
  );
  return False;
);

drop_sats {n}
  (inout state :: filter_state)
  (sdiff_sats :: gnss_signal_t[n])
  :: () := (
    while (drop_a_sat (inout state) sdiff_sats);
);

-- CHOOSE REF --

choose_ref {dim}
  (state :: filter_state)
  (sdiffs :: sdiff_t[dim])
  (ignore_current_sats :: bool)
  :: s32 := (

  index := -1;
  max_snr := -1000.0; -- TODO check units
  for i in dim -> (
    m := sdiffs[i];
    if m.snr >= max_snr and (ignore_current_sats or contains_sat m.sid state.sats) then (
        max_snr <- sdiffs[i].snr;
        index   <- i;
    ) else ();
  );

  return index;
);

-- CHANGE REF --

-- assumes sat is already part of the state
change_ref
  (inout sat_state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (

  -- have:
  -- xi = z_i - z_0
  -- xj = z_j - z_0
  -- want:
  -- xi = z_i - z_j
  -- xj = z_0 - z_j

  -- so xi <- xi - xj
  --    xj <- -xj
  --    satj <- sat0
  num_states := num_sats_to_num_states sat_state.num_sats;

  -- Construct change of basis matrix
  x_change :: double[num_states, num_states];
  p_change :: double[num_states, num_states];
  -- sat == sat_state.sats[j]
  sats_index := find_sat sat sat_state.sats;
  x_index := sats_index_to_x_index sats_index;
  ref_index := sats_index_to_x_index 0;
  x_change <- scalar 1.0;
  x_change[ref_index:,x_index] <- -1.0;
  p_change <- scalar 1.0;
  p_change[x_index, x_index] <- -1.0;
  -- Apply update
  new_x := x_change * sat_state.x[:num_states];
  new_p := p_change * sat_state.P[:num_states,:num_states] * p_change^T;

  -- Update state struct
  sat_state.sats[sats_index] <- sat_state.ref;
  sat_state.ref <- sat;
  sat_state.x[:num_states] <- new_x;
  sat_state.P[:num_states,:num_states] <- new_p;
);
-}
