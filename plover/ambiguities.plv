import prelude;
import qr;
import util;
import constants;
import observation_models;

-- ADD SAT --
add_sats {n_sdiffs}
  (inout state :: filter_state)
  (sdiff_sats :: gnss_signal_t[n_sdiffs])
  :: () := (
  array :: sat_array := all_sats state;
  for i in n_sdiffs -> (
    if not (contains_sat sdiff_sats[i] array.array) then
      add_sat (inout state) sdiff_sats[i]
  );
);

add_sat
  (inout state :: filter_state)
  (new_sat :: gnss_signal_t)
  :: () := (
  sig_new_amb :: double;
  new_sat_idx :: s32;

  if new_sat.code == CODE_GPS_L1CA then (
    sig_new_amb <- sig_init_p / GPS_L1_LAMBDA;
    new_sat_idx <- state.l1_ambs;
  ) else if new_sat.code == CODE_GPS_L2CM then (
    sig_new_amb <- sig_init_p / GPS_L2_LAMBDA;
    new_sat_idx <- state.l1_ambs + state.l2_ambs;
  ) else (
      printf "Invalid sat code found: %d\n" new_sat.code;
      assert False;
  );
  printf "ADD: "; print_sat new_sat; print_sat_state state;

  -- x index
  new_x_index := sats_index_to_x_index state new_sat_idx;
  p_new :: double[state.first_amb_idx + state.l1_ambs + state.l2_ambs + 1,
                  state.first_amb_idx + state.l1_ambs + state.l2_ambs + 1];

  -- add to sats
  new_sat_state := insert_sat state.sats new_sat_idx new_sat;
  -- add to x
  new_x := insert_double state.x new_x_index 0.0;
  -- add to P
  insert_dimension state.P new_x_index (out p_new);

  -- increment l1_ambs or l2_ambs
  increment_amb_count (inout state) new_sat;

  new_num_sats := get_num_sats state;
  new_x_dim := get_state_dimension state;
  -- copy values
  state.sats[:new_num_sats] <- new_sat_state[:new_num_sats];
  state.x[:new_x_dim] <- new_x[:new_x_dim];
  state.P[:new_x_dim, :new_x_dim] <- p_new[:new_x_dim, :new_x_dim];
);

-- DROP SAT --

-- returns index of dropped sat
drop_sat_state
  (target :: gnss_signal_t)
  (inout sat_state :: filter_state)
  :: s32 := (

  index := find_sat target sat_state.sats;

  if index >= 0 then (
    dim := get_num_sats sat_state;
    sat_state.sats[index:dim-1] <- sat_state.sats[index+1:dim];
  ) else (
    printf "ERROR; cannot drop. sat not found: "; print_sat target;
    printf "\n"; print_sat_state sat_state;
    assert False;
  );

  return index;
);

drop_sat
  (inout state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (
  printf "DROP: "; print_sat sat; printf " from "; print_sat_state state;
  printf "before drop:\n"; print_vec state.x; print_sats state.sats;
  index := drop_sat_state sat (inout state);
  x_index := sats_index_to_x_index state index;
  num_states := get_state_dimension state;
  x_temp := drop_i_1_double x_index state.x[:num_states];
  P_temp := drop_i_2 x_index (drop_i_2 x_index state.P[:num_states,:num_states]^T)^T;
  decrement_amb_count (inout state) sat;
  state.x[:num_states-1] <- x_temp;
  state.P[:num_states-1,:num_states-1] <- P_temp;
  printf "after drop:\n"; print_vec state.x; print_sats state.sats;
);

drop_a_sat {n}
  (inout state :: filter_state)
  (sdiff_sats :: gnss_signal_t[n])
  :: bool := (
  num_sats := get_num_sats state;
  for i in num_sats - 1 -> (
    if not (contains_sat state.sats[i] sdiff_sats) then (
      drop_sat (inout state) state.sats[i];
      return True;
    );
  );
  return False;
);

drop_sats {n}
  (inout state :: filter_state)
  (sdiff_sats :: gnss_signal_t[n])
  :: () := (
    while (drop_a_sat (inout state) sdiff_sats);
);

-- CHOOSE REF --

-- Works for any band
choose_ref_ {dim}
  (state :: filter_state)
  (sdiffs :: sdiff_t[dim])
  (ignore_current_sats :: bool)
  :: s32 := (

  index := -1;
  max_snr := -1000.0; -- TODO check units
  for i in dim -> (
    m := sdiffs[i];
    if m.snr >= max_snr and (ignore_current_sats or contains_sat m.sid state.sats) then (
        max_snr <- sdiffs[i].snr;
        index   <- i;
    ) else ();
  );

  return index;
);

choose_fresh_ref {dim}
  (sdiffs :: sdiff_t[dim])
  :: s32 := (
  dummy :: filter_state;
  choose_ref_ dummy sdiffs True;
);

choose_ref {dim}
  (state :: filter_state)
  (sdiffs :: sdiff_t[dim])
  :: s32 := choose_ref_ state sdiffs False;

-- CHANGE REF --

-- assumes sat is already part of the state
change_ref
  (inout state :: filter_state)
  (sat :: gnss_signal_t)
  :: () := (
  -- have:
  -- xi = z_i - z_0
  -- xj = z_j - z_0
  -- want:
  -- xi = z_i - z_j
  -- xj = z_0 - z_j

  -- so xi <- xi - xj
  --    xj <- -xj
  --    satj <- sat0
  num_states := get_state_dimension state;

  -- Construct change of basis matrix
  x_change :: double[num_states, num_states];
  p_change :: double[num_states, num_states];
  -- sat == sat_state.sats[j]
  sats_index := find_sat sat state.sats;
  x_index := sats_index_to_x_index state sats_index;

  lower_idx :: s32;
  upper_idx :: s32;
  get_index_bounds state sat (out lower_idx) (out upper_idx);

  x_change <- scalar 1.0;
  x_change[lower_idx:upper_idx, x_index] <- -1.0;
  p_change <- scalar 1.0;
  p_change[x_index, x_index] <- -1.0;

  -- Apply update
  new_x := x_change * state.x[:num_states];
  new_p := p_change * state.P[:num_states,:num_states] * p_change^T;

  -- Update state struct
  if sat.code == CODE_GPS_L1CA then (
    state.sats[sats_index] <- state.l1_ref;
    state.l1_ref <- sat;
  ) else if sat.code == CODE_GPS_L2CM then (
    state.sats[sats_index] <- state.l2_ref;
    state.l2_ref <- sat;
  );

  state.x[:num_states] <- new_x;
  state.P[:num_states,:num_states] <- new_p;
);
