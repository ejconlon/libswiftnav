-- TODO remove debug print statements
import prelude;
import qr;
import util;
import observation_models;
import ambiguities;
import process_models;

make_filter_state () :: filter_state := (
  s :: filter_state;
  s.first_amb_idx <- 3;
  -- Reset sat management
  reset_band (out s.l1_ambs) (out s.l1_valid);
  reset_band (out s.l2_ambs) (out s.l2_valid);
  -- Initial baseline state and covariance
  s.x <- 0.0;
  s.P <- scalar (sig_init_p^2);
  s;
);

reset_band
  (out num_ambs :: s32)
  (out validity_flag :: bool)
  :: () := (
  num_ambs <- 0;
  validity_flag <- False;
);

init_band {n_sdiffs}
  -- State object; needed by add_sats and the lesq initialization.
  (inout state :: filter_state)
  -- Views on filter state
  (out validity_flag :: bool)
  (out num_ambs :: s32)
  (out ref :: gnss_signal_t)
  (out sats :: gnss_signal_t[num_ambs])
  (out amb_estimates :: double [num_ambs])
  -- Initial data
  (input_sdiffs :: sdiff_t[n_sdiffs])
  (receiver_ecef :: double[3])
  (wavelength :: double)
  :: () := (
  ref_sat := input_sdiffs[choose_fresh_ref input_sdiffs].sid;
  change_ref (inout state) ref_sat;
  printf "Reset Filter! new reference: "; print_sat ref_sat; nl ();
  num_ambs <- 1;
  validity_flag <- True;

  add_sats (inout state) (vec i in n_sdiffs -> input_sdiffs[i].sid);

  sdiffs :: sdiff_t[num_ambs + 1];
  sdiffs <- input_sdiffs[:num_ambs + 1];
  reorder (vec(ref) # sats) (inout sdiffs);
  sat_positions := (vec i in num_ambs+1 -> sdiffs[i].sat_pos);

  iterative_least_squares sdiffs receiver_ecef sat_positions wavelength
    (inout state.x[:3]) (inout amb_estimates);
);

-- TODO fix `a # b <- c;`
modify {n} (out left :: double[n]) (right :: double[n]) :: () := left <- right;

iterative_least_squares {n_sdiffs}
  (sdiffs :: sdiff_t[n_sdiffs])
  (receiver_ecef :: double[3])
  (sat_positions :: double[n_sdiffs, 3])
  (wavelength :: double)
  -- View on filter state
  (inout baseline :: double[3])
  (inout amb_estimates :: double[n_sdiffs-1])
  :: () := (

  y :: double[2*(n_sdiffs-1)];
  H :: double[2*(n_sdiffs-1), n_sdiffs+2];
  R :: double[2*(n_sdiffs-1), 2*(n_sdiffs-1)];

  max_iterations := 5;
  for j in max_iterations -> (
    -- TODO: Add decorrelation and regularization?
    orthogonal_observation_model_
      (vec i in : -> sdiffs[i].pseudorange)
      (vec i in : -> sdiffs[i].carrier_phase)
      baseline[0:3] receiver_ecef sat_positions wavelength
      (out y) (out H[:,:3]) (out H[:,:n_sdiffs-1]) (out R);
    y_hat := y - H * (baseline # amb_estimates);
    delta_x_hat :: double[n_sdiffs+2];
    residual :: double;
    qr_solve (inout H^T * H) (inout H^T * y_hat) (out delta_x_hat) (out residual);
    modify (out baseline # amb_estimates) ((baseline # amb_estimates) + delta_x_hat);
  );
);

kalman_predict_ {dim}
  (x :: double[dim])
  (P :: double[dim, dim])
  (F :: Scalar double[dim, dim])
  (Q :: Diagonal double[dim, dim])
  (out x_new :: double[dim])
  (out P_new :: double[dim, dim])
  :: () := (
  P_new <- F * P * F^T + Q;
  x_new <- F * x;
);

kalman_update_ {xdim, dim}
  (x :: double[xdim])
  (P :: double[xdim, xdim])
  (y :: double[dim])
  (H :: double[dim, xdim])
  (R :: double[dim, dim])
  (out x_new :: double[xdim])
  (out P_new :: double[xdim, xdim])
  :: () := (

  innovation := y - H * x;

  PHt := P * H^T;
  S := H * PHt + R;
  K := PHt * S^(-1) :: double[xdim, dim];

  x_new <- x + K * innovation;
  P_new <- (scalar 1.0 - K * H) * P;
);

l1_l2_observation_model_update
  { l1_sdiff_dim, l2_sdiff_dim }
  (inout state :: filter_state)
  (base_pos_ecef :: double[3])
  (l1_sdiffs :: sdiff_t[l1_sdiff_dim])
  (l2_sdiffs :: sdiff_t[l2_sdiff_dim])
  :: () := (

  y1 :: double[2*state.l1_ambs];
  H1_base :: double[2*state.l1_ambs, state.first_amb_idx];
  H1_ambs :: double[2*state.l1_ambs, state.l1_ambs];
  R1 :: double[2*state.l1_ambs, 2*state.l1_ambs];

  y2 :: double[2*state.l2_ambs];
  H2_base :: double[2*state.l2_ambs, state.first_amb_idx];
  H2_ambs :: double[2*state.l2_ambs, state.l2_ambs];
  R2 :: double[2*state.l2_ambs, 2*state.l2_ambs];

  if state.l1_valid then (
    l1_sat_positions  := vec i in :state.l1_ambs+1 -> l1_sdiffs[i].sat_pos;
    l1_pseudoranges   := vec i in :state.l1_ambs+1 -> l1_sdiffs[i].pseudorange;
    l1_carrier_phases := vec i in :state.l1_ambs+1 -> l1_sdiffs[i].carrier_phase;
    orthogonal_observation_model_
      l1_pseudoranges
      l1_carrier_phases
      state.x[0:3] base_pos_ecef l1_sat_positions GPS_L1_LAMBDA
      (out y1) (out H1_base) (out H1_ambs) (out R1)
  );

  if state.l2_valid then (
    l2_sat_positions := vec i in :state.l2_ambs+1 -> l2_sdiffs[i].sat_pos;
    l2_pseudoranges   := vec i in :state.l2_ambs+1 -> l2_sdiffs[i].pseudorange;
    l2_carrier_phases := vec i in :state.l2_ambs+1 -> l2_sdiffs[i].carrier_phase;
    orthogonal_observation_model_
      l2_pseudoranges
      l2_carrier_phases
      state.x[0:3] base_pos_ecef l2_sat_positions GPS_L2_LAMBDA
      (out y2) (out H2_base) (out H2_ambs) (out R2)
  );

  -- nb: if band i is invalid, then yi, Ri, and Hi_{base,ambs} will all have zero rows

  -- Form composite H matrix
  -- TODO horizontal concat operator
  H :: double[2*(state.l1_ambs+state.l2_ambs),
              state.first_amb_idx + state.l1_ambs + state.l2_ambs];
  H <- ((H1_base # H2_base)^T #
          (block_diagonal H1_ambs H2_ambs)^T)^T;

  -- Use : to force a copy of state.x, state.P
  -- Writes output directly into state.x, state.P
  kalman_update_ state.x[:] state.P[:,:]
    (y1 # y2) H (block_diagonal R1 R2)
    (out state.x) (out state.P)
);

update_filter
  (inout state :: filter_state)
  (input_l1_sdiffs :: sdiff_t[state.l1_ambs+1])
  (input_l2_sdiffs :: sdiff_t[state.l2_ambs+1])
  (base_receiver_ecef :: double[3])
  :: () := (

  -- We want to reorder and "resize" the sdiffs and sat_positions
  l1_sdiffs := input_l1_sdiffs;
  l2_sdiffs := input_l2_sdiffs;
  reorder (vec(state.l1_ref) # state.sats[:state.l1_ambs]) (inout l1_sdiffs);
  reorder (vec(state.l2_ref) # state.sats[:state.l2_ambs]) (inout l2_sdiffs);

  -- Process model
  F :: Scalar double[state.first_amb_idx + state.l1_ambs + state.l2_ambs,
                       state.first_amb_idx + state.l1_ambs + state.l2_ambs];
  Q :: Diagonal double[state.first_amb_idx + state.l1_ambs + state.l2_ambs,
                       state.first_amb_idx + state.l1_ambs + state.l2_ambs];
  process_model (out F) (out Q);

  kalman_predict_ state.x[:] state.P[:]
    F Q (out state.x) (out state.P);

  -- Calculate observation model and call kalman_update
  l1_l2_observation_model_update
    (inout state) base_receiver_ecef
    l1_sdiffs l2_sdiffs
);

update_
  { l1_sdiff_dim, l2_sdiff_dim }
  (inout state :: filter_state)
  (l1_sdiffs :: sdiff_t[l1_sdiff_dim])
  (l2_sdiffs :: sdiff_t[l2_sdiff_dim])
  (receiver_ecef :: double[3])
  -- ? (raim flag)
  :: () := (
  -- Sat management
  -- TODO: separate state components for l1 and l2
  update_sats (inout state)
    (inout state.l1_valid) (inout state.l1_ref) (out state.l1_ambs)
    (out state.sats[:state.l1_ambs])
    (out state.x[state.first_amb_idx:state.first_amb_idx+state.l1_ambs])
    l1_sdiffs GPS_L1_LAMBDA receiver_ecef;
  update_sats (inout state)
    (inout state.l2_valid) (inout state.l2_ref) (out state.l2_ambs)
    (out state.sats[state.l1_ambs:])
    (out state.x[state.first_amb_idx+state.l1_ambs:])
    l2_sdiffs GPS_L2_LAMBDA receiver_ecef;

  -- Assert that sat sets are consistent
  assert state.l1_ambs + 1 == l1_sdiff_dim;
  assert state.l2_ambs + 1 == l2_sdiff_dim;

  for i in l1_sdiff_dim -> assert (
    contains_sat l1_sdiffs[i].sid state.sats or
    sid_is_equal l1_sdiffs[i].sid state.l1_ref
  );
  for i in l1_sdiff_dim -> assert (
    contains_sat l2_sdiffs[i].sid state.sats or
    sid_is_equal l2_sdiffs[i].sid state.l2_ref
  );

  -- Filter
  update_filter (inout state)
    l1_sdiffs[:state.l1_ambs+1]
    l2_sdiffs[:state.l2_ambs+1]
    receiver_ecef;
);
