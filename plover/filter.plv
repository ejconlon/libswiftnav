-- TODO remove debug print statements
import prelude;
import qr;
import util;
import operations;

make_filter_state () :: filter_state := (
  s :: filter_state;
  s.invalid <- True;
  s.num_sats <- 0;
  s;
);

kalman_init_
  (out state :: filter_state)
  (ref :: gnss_signal_t)
  :: () := (
  sig_init_p := 1.0e3;
  printf "Reset Filter! new reference: "; print_sat ref; nl ();
  state.num_sats <- 1;
  state.ref <- ref;
  state.invalid <- False;
  state.x <- 0.0;
  position_covariance :: double[state.num_sats + 2, state.num_sats + 2];
  position_covariance[:3, :3] <- scalar (sig_init_p^2);
  state.P <- position_covariance;
);

kalman_predict_ {dim}
  (x :: double[dim])
  (P :: double[dim, dim])
  (F :: double[dim, dim])
  (Q :: double[dim, dim])
  (out x_new :: double[dim])
  (out P_new :: double[dim, dim])
  :: () := (
  P_new <- F * P * F^T + Q;
  x_new <- F * x;
);

kalman_update_ {xdim, dim}
  (x :: double[xdim])
  (P :: double[xdim, xdim])
  (y :: double[dim])
  (H :: double[dim, xdim])
  (R :: double[dim, dim])
  (out x_new :: double[xdim])
  (out P_new :: double[xdim, xdim])
  :: () := (

  innovation := y - H * x;

  PHt := P * H^T;
  S := H * PHt + R;
  K := PHt * S^(-1) :: double[xdim, dim];

  x_new <- x + K * innovation;
  P_new <- (scalar 1.0 - K * H) * P;

  printf "after update:\n"; print_mat P_new; nl ();
);

omega_dot_unit_vector {sats, dim}
  (base_pos :: double[dim])
  (sat_positions :: double[sats, dim])
  (estimate :: double[dim])
  :: double[sats, dim] := (

  vec i in sats -> (
    h := sat_positions[i] - base_pos;
    omega := norm h + norm (h - estimate);
    (2*h - estimate) / omega
  );
);

orthogonal_observation_model_ {sats}
  (pseudoranges :: double[sats])
  (carrier_phases :: double[sats])
  (x :: double[3])
  (base_pos :: double[3])
  (sat_positions :: double[sats, 3])

  (sig_cp :: double)
  (sig_pr :: double)

  (out y :: double[2*(sats-1)])
  (out H :: double[2*(sats-1), 3+(sats-1)])
  (out R :: double[2*(sats-1), 2*(sats-1)])
  :: () := (

  E :: double[sats, 3];
  E <- (omega_dot_unit_vector base_pos sat_positions x[0:3]) / GPS_L1_LAMBDA;
  --printf "\nE:\n"; print_mat_upsidedown E;
  u :: double[sats];
  u <- -1.0 / sqrt sats;
  u[0] <- u[0] + 1;

  P_bar :: double[sats-1, sats];
  P_bar <- (scalar 1.0 - 2 * (u * u^T) / (u * u))[1:];
  --printf "\nP_bar:\n"; print_mat_upsidedown P_bar;
  F :: double[sats-1, sats-1] :=
    scalar 1.0 - (1 / (sats - sqrt sats));
  --printf "F:\n"; print_mat_upsidedown F;
  sig_ratio := sig_cp / (sig_pr / GPS_L1_LAMBDA);

  -- Outputs
  y <- (P_bar * carrier_phases) #
         (sig_ratio * P_bar * pseudoranges / GPS_L1_LAMBDA);
  --printf "\ny:\n"; print_mat_upsidedown y;
  -- block: [PE, F; sig_ratio*PE, 0]
  PE := P_bar * E;
  H <- ((PE^T # F^T)^T # ((sig_ratio * PE^T) # scalar 0.0)^T);
  --printf "\n H:"; print_mat_upsidedown H;
  R <- 4 * sig_cp * scalar 1.0;
);

direct_observation_model_ {sats}
  (pseudoranges :: double[sats])
  (carrier_phases :: double[sats])
  (x :: double[3])
  (base_pos :: double[3])
  (sat_positions :: double[sats, 3])

  (sig_cp :: double)
  (sig_pr :: double)

  (out y :: double[2*(sats-1)])
  (out H :: double[2*(sats-1), 3+(sats-1)])
  (out R :: double[2*(sats-1), 2*(sats-1)])
  :: () := (

  E :: double[sats, 3];
  E <- (omega_dot_unit_vector base_pos sat_positions x[0:3]) / GPS_L1_LAMBDA;

  D :: double[sats-1, sats];
  D[0:, 1:] <- scalar 1.0;
  D[:,0] <- -1.0; -- reference is first

  sig_ratio := sig_cp / (sig_pr / GPS_L1_LAMBDA);
  -- Outputs
  y <- ((D * carrier_phases) # (sig_ratio * D * pseudoranges / GPS_L1_LAMBDA));

  eye :: double[sats-1, sats-1];
  eye <- scalar 1.0;
  zeros :: double[sats-1, sats-1];
  zeros <- 0.0;
  left := (D * E) # (D * E);
  right := eye # zeros;
  H <- (left^T # right^T)^T;
  --printf "\n H:"; print_mat_upsidedown H;
  R <- 4 * sig_cp * scalar 1.0; -- TODO
);

process_model {dim}
  (out F :: double[dim, dim])
  (out Q :: double[dim, dim])
  (sig_x :: double)
  (sig_z :: double)
  :: () := (
  F <- scalar 1.0;
  diagonal :: double[dim];
  diagonal[:3] <- (sig_x^2);
  diagonal[3:] <- (sig_z^2);
  sigma :: Diagonal double[dim, dim];
  sigma <- diagonal;
  Q <- sigma;
);

update_ {n_sdiffs}
  (inout state :: filter_state)
  (input_sdiffs :: measurement[n_sdiffs])
  (receiver_ecef :: double[3])
  (sat_positions :: double[n_sdiffs, 3])
  -- ? (raim flag)
  :: () := (

  -- TODO - Tune these constants
  sig_cp := 0.02;
  sig_pr := 3.0;
  sig_x := 2.0;
  sig_z := 10.0;
  sig_init_p := 1.0e3;

  -- We want to reorder them
  sdiffs := input_sdiffs;

  -- Filter reset
  if n_sdiffs == 0 then (
    printf "empty filter\n";
    state <- make_filter_state ();
    return;
  );
  if state.invalid then kalman_init_ (out state) sdiffs[0].sat_id;

  new_sats := vec i in n_sdiffs -> sdiffs[i].sat_id;

  -- Update the reference
  if not (contains_sat state.ref new_sats) then (
    index := choose_ref state sdiffs;
    if index < 0 then (
      kalman_init_ (out state) sdiffs[0].sat_id;
    ) else (
      printf "CHANGE REF: ";
      print_sat sdiffs[index].sat_id; nl ();
      change_ref (inout state) sdiffs[index].sat_id;
    );

  );
  -- Drop any missing sats
  print_vec state.x;
  print_sat_state state;
  while (drop_a_sat (inout state) new_sats);
  print_vec state.x;
  print_sat_state state;

  -- Add any new sats
  sig_new_amb := (sig_init_p / GPS_L1_LAMBDA)^2;
  for i in n_sdiffs -> (
    if not (contains_sat new_sats[i] state.sats or sid_is_equal new_sats[i] state.ref) then
      add_sat (inout state) new_sats[i] sig_new_amb
  );
  print_vec state.x;
  print_sat_state state;
  -- Assert that sat sets are consistent
  assert state.num_sats == n_sdiffs;
  for i in n_sdiffs -> assert (
    contains_sat sdiffs[i].sat_id state.sats or
    sid_is_equal sdiffs[i].sat_id state.ref
  );

  -- Begin KF update

  -- reorder sdiffs
  reorder (vec(state.ref) # state.sats[:n_sdiffs-1]) (inout sdiffs);

  -- Process model
  F :: double[n_sdiffs+2, n_sdiffs+2];
  Q :: double[n_sdiffs+2, n_sdiffs+2];
  process_model (out F) (out Q) sig_x sig_z;

  x_new_1 :: double[n_sdiffs+2];
  P_new_1 :: double[n_sdiffs+2, n_sdiffs+2];
  kalman_predict_ state.x[:n_sdiffs+2] state.P[:n_sdiffs+2,:n_sdiffs+2]
    F Q (out x_new_1) (out P_new_1);

  -- Measurement update
  y :: double[2*(n_sdiffs-1)];
  H :: double[2*(n_sdiffs-1), n_sdiffs+2];
  R :: double[2*(n_sdiffs-1), 2*(n_sdiffs-1)];

  orthogonal_observation_model_
    (vec i in : -> sdiffs[i].pseudorange)
    (vec i in : -> sdiffs[i].carrier_phase)
    x_new_1[0:3] receiver_ecef sat_positions sig_cp sig_pr
    (out y) (out H) (out R);

  x_new_2 :: double[n_sdiffs+2];
  P_new_2 :: double[n_sdiffs+2, n_sdiffs+2];
  kalman_update_ x_new_1 P_new_1 y H R
    (out x_new_2) (out P_new_2);

  state.x[:n_sdiffs+2] <- x_new_2;
  state.P[:n_sdiffs+2, :n_sdiffs+2] <- P_new_2;
);
