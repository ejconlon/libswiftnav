-- TODO remove debug print statements
import prelude;
import qr;
import util;
import observation_models;
import ambiguities;
import process_models;

make_filter_state () :: filter_state := (
  s :: filter_state;
  s.invalid <- True;
  s.num_sats <- 0;
  s;
);

iterative_least_squares {n_sdiffs}
  (inout state :: filter_state)
  (sdiffs :: sdiff_t[n_sdiffs])
  (receiver_ecef :: double[3])
  (sat_positions :: double[n_sdiffs, 3])
  :: () := (

  y :: double[2*(n_sdiffs-1)];
  H :: double[2*(n_sdiffs-1), n_sdiffs+2];
  R :: Scalar double[2*(n_sdiffs-1), 2*(n_sdiffs-1)];

  max_iterations := 5;
  for j in max_iterations -> (
    -- TODO: Add decorrelation and regularization?
    orthogonal_observation_model_
    (vec i in : -> sdiffs[i].pseudorange)
    (vec i in : -> sdiffs[i].carrier_phase)
    state.x[0:3] receiver_ecef sat_positions (out y) (out H) (out R);
    y_hat := y - H * state.x[:n_sdiffs+2];
    delta_x_hat :: double[n_sdiffs+2];
    residual :: double;
    qr_solve (inout H^T * H) (inout H^T * y_hat) (out delta_x_hat) (out residual);
    state.x[:n_sdiffs+2] <- state.x[:n_sdiffs+2] + delta_x_hat;
  );
);

kalman_init_ {n_sdiffs}
  (inout state :: filter_state)
  (input_sdiffs :: sdiff_t[n_sdiffs])
  (receiver_ecef :: double[3])
  :: () := (
  index := choose_ref state input_sdiffs True;
  ref_sat := input_sdiffs[index].sid;
  change_ref (inout state) ref_sat;
  printf "Reset Filter! new reference: "; print_sat ref_sat; nl ();
  state.num_sats <- 1;
  state.ref <- ref_sat;
  state.invalid <- False;
  state.x <- 0.0;
  position_covariance :: double[state.num_sats + 2, state.num_sats + 2];
  position_covariance[:3, :3] <- scalar (sig_init_p^2);
  state.P <- position_covariance;

  sdiff_sats := vec i in n_sdiffs -> input_sdiffs[i].sid;

  add_sats (inout state) sdiff_sats;

  sdiffs :: sdiff_t[state.num_sats];
  sdiffs <- input_sdiffs[:state.num_sats];
  reorder (vec(state.ref) # state.sats) (inout sdiffs);
  sat_positions := (vec i in state.num_sats -> sdiffs[i].sat_pos);

  iterative_least_squares (inout state) sdiffs receiver_ecef sat_positions;
);

kalman_predict_ {dim}
  (x :: double[dim])
  (P :: double[dim, dim])
  (F :: Scalar double[dim, dim])
  (Q :: Diagonal double[dim, dim])
  (out x_new :: double[dim])
  (out P_new :: double[dim, dim])
  :: () := (
  P_new <- F * P * F^T + Q;
  x_new <- F * x;
);

kalman_update_ {xdim, dim}
  (x :: double[xdim])
  (P :: double[xdim, xdim])
  (y :: double[dim])
  (H :: double[dim, xdim])
  (R :: Scalar double[dim, dim])
  (out x_new :: double[xdim])
  (out P_new :: double[xdim, xdim])
  :: () := (

  innovation := y - H * x;

  PHt := P * H^T;
  S := H * PHt + R;
  K := PHt * S^(-1) :: double[xdim, dim];

  x_new <- x + K * innovation;
  P_new <- (scalar 1.0 - K * H) * P;
);

update_ {n_sdiffs}
  (inout state :: filter_state)
  (input_sdiffs :: sdiff_t[n_sdiffs])
  (receiver_ecef :: double[3])
  -- ? (raim flag)
  :: () := (

  -- Filter reset
  if n_sdiffs == 0 then (
    printf "empty filter\n";
    state <- make_filter_state ();
    return;
  );

  if state.invalid then kalman_init_ (inout state) input_sdiffs receiver_ecef;

  sdiff_sats := vec i in n_sdiffs -> input_sdiffs[i].sid;

  -- Update the reference
  if not (contains_sat state.ref sdiff_sats) then (
    index := choose_ref state input_sdiffs False;
    if index < 0 then (
      printf "No reference found! Resetting";
      kalman_init_ (inout state) input_sdiffs receiver_ecef
    ) else (
      printf "new ref: ";
      print_sat input_sdiffs[index].sid; nl ();
      change_ref (inout state) input_sdiffs[index].sid;
    );
  );

  -- Drop any missing sats
  drop_sats (inout state) sdiff_sats;

  -- Add any new sats
  -- TODO choose new ref occasionally?
  add_sats (inout state) sdiff_sats;

  -- Assert that sat sets are consistent
  assert state.num_sats == n_sdiffs;
  for i in n_sdiffs -> assert (
    contains_sat input_sdiffs[i].sid state.sats or
    sid_is_equal input_sdiffs[i].sid state.ref
  );

  -- We want to reorder and "resize" the sdiffs and sat_positions
  sdiffs :: sdiff_t[state.num_sats];
  sdiffs <- input_sdiffs[:state.num_sats];
  reorder (vec(state.ref) # state.sats) (inout sdiffs);
  sat_positions := (vec i in state.num_sats -> sdiffs[i].sat_pos);

  -- Process model
  F :: Scalar double[state.num_sats+2, state.num_sats+2];
  Q :: Diagonal double[state.num_sats+2, state.num_sats+2];
  process_model (out F) (out Q);

  x_new_1 :: double[state.num_sats+2];
  P_new_1 :: double[state.num_sats+2, state.num_sats+2];
  kalman_predict_ state.x state.P
    F Q (out x_new_1) (out P_new_1);

  -- Measurement update
  y :: double[2*(state.num_sats-1)];
  H :: double[2*(state.num_sats-1), state.num_sats+2];
  R :: Scalar double[2*(state.num_sats-1), 2*(state.num_sats-1)];

  orthogonal_observation_model_
    (vec i in : -> sdiffs[i].pseudorange)
    (vec i in : -> sdiffs[i].carrier_phase)
    x_new_1[0:3] receiver_ecef sat_positions
    (out y) (out H) (out R);

  -- Save a temporary by storing directly into state struct
  kalman_update_ x_new_1 P_new_1 y H R
    (out state.x) (out state.P);
);
